# 各模块涉及的表、表与表之间的关系

model 里面的实体对应数据库中的表。

---

## 1 首页

涉及的表：

1.  activity：简单的活动查询
2. banner：banner 查询
3. banner_item：banner 子项
4. grid_category：简单的分类查询
5. theme：主题查询
6. spu：spu 列表分页查询
7. theme_spu：主题与 spu 关联查询

表与表之间的关系：

1. banner 与 banner_item 一对多，一个 banner 可以包含多个 banner_item。
2. theme 与 spu 多对多，一些 theme 可以包含 spu 列表，同一个 spu 也可以同时属于多个 theme。

---

## 2 商品详情

### 涉及的表

1. spu：所有的商品
2. sku：所有的商品下的规格
3. 规格：由两张表组成
    1. spec_key：规格名称
    2. spec_value：规格值
4. sku_spec：该表中每一行都是一个确定的规格值。
5. spu_key：

### 表与表之间的关系

1. spu 与 sku 一对多，一个 sku 必然是属于某个 spu 的。
2. spec_key 与 spec_value 一对多，一个 spec 可以有多个值，比如颜色有红色、蓝色。
3. spu 和 spec_key 多对多。
    1. 某些规格并不只适用于特定的一个商品，比如很多商品都有颜色规格。
    1. 因此这里没有第三张表建立 sku 与 spec 之间的多对多关系，表面上看规格是属于 sku 的，但是这里建立 sku 与 spec 之间的关系不太合适，最好的方式是建立 spec_key 与 spu 之间的关系。
    2. spu 代表某一个商品，而商品下面有哪些规格是确定的，无论其有多少个 sku，这些 sku 的规格名其实都是先相同的，所以建立规格和 spu 的关系更加简单。这个多对多的关系记录在 spu_key 表中。
4. sku 与 spec_value 多对多。
    1. 一个 sku 有多个规格，但是 sku 下的规格值都是确定的，比如某个 sku 可以为【`颜色：红色 + Size：M`】，所以可以认为 sku 与 spec_value 多对多 。
    2. sku_spec 表中记录了 sku, spec_value 之间的多对多关系，但是为了方便查询，sku_spec 表中多加了 `spu_id` 和 `key_id` 两个字段。

### 设计说明

1. 规格是抽象的，规格可以划分为标准规则或非标准规格，比如可以认为颜色是标准规格，很多商品都是由颜色熟悉的，因此可以建立一个颜色库。
2. 规格是一种非常主观上的定义。
3. spec_key 中的 standard 字段用于标识该规则是否是标准规格。
4. 【sku 与 spec_key 也可以设计成一对多的关系，即某个规格只能特定属于某一个 sku。即 sku 与 spec_key 设计成一对多的关系】

sku 中的 specs, code字段

1. 完整的数据库（字段的和表可以涵盖业务需要的设计）设计并不一定就是好的数据库。因为数据库的设计还需要去考虑前端业务的需要。
2. sku 中 specs 看起来是一种冗余的设计，但是这个字段可以很好地满足前端的需要和优化查询次数。
    1. 如果没有 specs 字段，那么查询的顺序是 `spu->sku-spec.key/spec.value`，其实对应一个 sku 来说，**它的规格值其实是确定的**，因此可以将这些规格值存储到 sku 的一个字段上，即 specs。
    2. specs 用于表达 sku 的相关规格，要存储一组规则值显然用对象来表示最合适，因此这里需要在数据库的一个字段中存储一个对象，比较通用的方式是将对象序列化为字符串（比如 json）存储到 specs 字段中。
    3. code 也是冗余设计，code 是一个 sku 的唯一标识，虽然 sku 的 id 也是唯一标识，但是 code 本身体现了前端用户的动态选择过程。code 的格式 `spu_id$spec_key_id-spec_value_id#spu_id$spec_key_id-spec_value_id`。

### 遗留问题

---

## 3 商品分类

涉及到的表：

- category：分类查询

---

## 4 优惠券

### 4.1 优惠券的整体设计

优惠券的业务流程：

1. 创建 CMS
2. 选择类型：`参数、满减`...等。
3. 审核
4. 投放
5. 领取：`定时/抢券/赠送`等方式。
6. 使用
7. 优惠券的核销。
8. 使用了优惠券的商品的退款的处理。

其他概念：

- 模板【可选】：优惠券类型即功能的抽象，有了优惠券的模板的概念，针对功能类似的优惠券就可以实现复用了。
- 活动：优惠券是通过活动发放的。
- 品类：不是所有的优惠券都是全程券，有些优惠券只能用于某些品类的商品。

### 4.2 涉及到的表

- coupon：用于存储所有的优惠券，该项目设计了四种优惠券，包括`满减券、折扣券、无门槛券、满金额折扣券`。
- activity
- category
- user
- user_coupon：用于维护 user 和 coupon 之间的多对多关系，但是这张关系表比较特殊，还包含了特殊的意义，所以需要手动维护。

### 4.3 表之间的关系与表的设计

#### 4.3.1 活动与优惠券之间的关系

活动与优惠券之间的关系是多对多的，不同的活动可以发放相同的优惠券。

#### 4.3.2 用户与优惠券的多对多关系

相关表：`user_coupon`，因为这张表带有实际的业务意义，所以定义了 UserCoupon 实体类。

1. 用户与优惠券是多对多关系，需要第三方表来维护。
2. 但是这张关系表又有实际的业务意义，所以需要手动来维护，JPA 虽然支持自定义关系表，但是写起来很麻烦。

所谓的带有实际的业务意义，即在 `user_coupon` 中除了有`user` 和`coupon` 的主键字段外，还有其他的业务相关的字段。

####  4.3.3 活动、优惠券与分类之间的关系

不是所有的优惠券都是全场券，所以有些优惠券必然要和分类产生关联，所以优惠券和分类之间是多对多关系，但是优惠券又肯定是通过活动发放的，怎么设计这三者之间的关系呢？

- 方式 1 是：定义优惠券和分类的多对多关系。【优点：方便查询，但是优惠券的灵活度降低，因为该优惠会就被限定在某个分类上，对于别的分类，即使是功能一样的优惠券，也需要重新创建一个优惠券】

但是优惠券又是通过活动发放的。是不是可以定义活动和分类之间的关系而不定义优惠券和分类之间的关系呢？可以的。

- 因此，方式 2 是：活动和分类有关系，从而优惠券与分类间接产生关系。【优点：优惠券的灵活度高，没有固定在某个分类下。】

但是，优惠券一定和活动是有关系的，因为优惠券是通过活动发放的。

**两种方式带来的影响**：查询某个商品它能够使用哪些优惠券：

- 方式1的查询：SPU-->Category-->优惠券
- 方式2的查询：SPU-->Category-->Activity-->优惠券【比较繁琐】

考虑到性能问题，这里选择的还是第一种方案，另外对于优惠券的灵活度，通过引入模板的概念来解决【优惠券模板在这个阶段没有体现，会在 CSM 阶段体现】，

另外还有一个约定约定：该项目优惠券与二级分类进行关联，这可以降低业务复杂度。

>现有的表中，保留了 `activity_category` 表，用于支持 activity 和 category 之间的多对多关系，但是项目中并没有使用到。

#### 4.3.4 活动与优惠券的多对多关系转化为一对多关系

理论：一个多对多可以转化为两个一对多。

比如：优惠券和活动是多对多的，为什么是多对多的，因为我们希望优惠券可以复用（可用于多个活动），但是这样设计会导致查询变得复杂，那么有什么办法既可以将活动和优惠券设计成一对多，又能保持优惠券的复用性呢？可以的，一个多对多可以转化为两个一对多，于是我们引入优惠券模板的概念，于是它们之间的关系变为：`优惠券模板<-->优惠券<-->活动`。这样设计
是为了增强优惠券的复用性。

如何选择多对多和一对多关系？如果都可以，那么应该优先选择一对多关系，而如何判断是否需要使用多对多关系，需要考虑的一大因素就是复用性。

>现有的表中，保留了 `activity_coupon` 表，用于支持它们之间的多对多关系，但是项目中并没有使用到。
